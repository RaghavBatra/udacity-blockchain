/**
 *                          Block class
 *  The Block class is a main component into any Blockchain platform,
 *  it will store the data and act as a dataset for your application.
 *  The class will expose a method to validate the data... The body of
 *  the block will contain an Object that contain the data to be stored,
 *  the data should be stored encoded.
 *  All the exposed methods should return a Promise to allow all the methods
 *  run asynchronous.
 */

const SHA256 = require('crypto-js/sha256');
const hex2ascii = require('hex2ascii');

class Block {

    // Constructor - argument data will be the object containing the transaction data
	constructor(data){
		this.hash = null;                                           // Hash of the block
		this.height = 0;                                            // Block Height (consecutive number of each block)
		this.body = Buffer(JSON.stringify(data)).toString('hex');   // Will contain the transactions stored in the block, by default it will encode the data
		this.time = 0;                                              // Timestamp for the Block creation
		this.previousBlockHash = null;                              // Reference to the previous Block Hash
  }

    /**
     *  validate() method will validate if the block has been tampered or not.
     *  Been tampered means that someone from outside the application tried to change
     *  values in the block data as a consecuence the hash of the block should be different.
     *  Steps:
     *  1. Return a new promise to allow the method be called asynchronous.
     *  2. Save the in auxiliary variable the current hash of the block (`this` represent the block object)
     *  3. Recalculate the hash of the entire block (Use SHA256 from crypto-js library)
     *  4. Compare if the auxiliary hash value is different from the calculated one.
     *  5. Resolve true or false depending if it is valid or not.
     *  Note: to access the class values inside a Promise code you need to create an auxiliary value `let self = this;`
     */
  validate() {
      let self = this;
      return new Promise((resolve, reject) => {
      // Save in auxiliary variable the current block
      let auxHash = self.hash;
      // Recalculate the hash of the Block
      let recalcHash = SHA256(JSON.stringify(self.data)).toString();
      // Comparing if the hashes changed
      if (auxHash == recalcHash) {
        resolve(true);
        }
      // Returning the Block is valid
      else {
        resolve(false);
        }
      // Returning the Block is not valid
    });
  }

    /**
     *  Auxiliary Method to return the block body (decoding the data)
     *  Steps:
     *
     *  1. Use hex2ascii module to decode the data
     *  2. Because data is a javascript object use JSON.parse(string) to get the Javascript Object
     *  3. Resolve with the data and make sure that you don't need to return the data for the `genesis block`
     *     or Reject with an error.
     */
   getBData() {
         let self = this;
         return new Promise((resolve, reject) => {
           resolve(JSON.parse(hex2ascii(self.body)));

           // // put try catch
           //
           //   // Getting the encoded data saved in the Block
           //   let auxData = self.body;
           //   // Decoding the data to retrieve the JSON representation of the object
           //   let auxDataASCII = hex2ascii(auxData);
           //   // Parse the data to an object to be retrieved.
           //   let parsedData = JSON.parse(auxDataASCII);
           //   // Resolve with the data if the object isn't the Genesis block
           //   if (self.height == 0) {
           //     reject("Accessing Genesis Block!");
           //   }
           //   else {
           //     resolve(parsedData);
           //   }
         });
  }


}

module.exports.Block = Block;                    // Exposing the Block class as a module


-----------------------------------------------------------------------------------


/**
 *                          Blockchain Class
 *  The Blockchain class contain the basics functions to create your own private blockchain
 *  It uses libraries like `crypto-js` to create the hashes for each block and `bitcoinjs-message`
 *  to verify a message signature. The chain is stored in the array
 *  `this.chain = [];`. Of course each time you run the application the chain will be empty because and array
 *  isn't a persisten storage method.
 *
 */

const SHA256 = require('crypto-js/sha256');
const BlockClass = require('./block.js');
const bitcoinMessage = require('bitcoinjs-message');

class Blockchain {

    /**
     * Constructor of the class, you will need to setup your chain array and the height
     * of your chain (the length of your chain array).
     * Also everytime you create a Blockchain class you will need to initialized the chain creating
     * the Genesis Block.
     * The methods in this class will always return a Promise to allow client applications or
     * other backends to call asynchronous functions.
     */
    constructor() {
        this.chain = [];
        this.height = -1;
        this.initializeChain();
    }

    /**
     * This method will check for the height of the chain and if there isn't a Genesis Block it will create it.
     * You should use the `addBlock(block)` to create the Genesis Block
     * Passing as a data `{data: 'Genesis Block'}`
     */
    async initializeChain() {
        if( this.height === -1){
            let block = new BlockClass.Block({data: 'Genesis Block'});
            await this._addBlock(block);
        }
    }

    /**
     * Utility method that return a Promise that will resolve with the height of the chain
     */
    getChainHeight() {
        return new Promise((resolve, reject) => {
            resolve(this.height);
        });
    }

    /**
     * _addBlock(block) will store a block in the chain
     * @param {*} block
     * The method will return a Promise that will resolve with the block added
     * or reject if an error happen during the execution.
     * You will need to check for the height to assign the `previousBlockHash`,
     * assign the `timestamp` and the correct `height`...At the end you need to
     * create the `block hash` and push the block into the chain array. Don't for get
     * to update the `this.height`
     * Note: the symbol `_` in the method name indicates in the javascript convention
     * that this method is a private method.
     */
    _addBlock(block) {
        let self = this;
        return new Promise(async (resolve, reject) => {

          // check for errors
          try {

            // genesis block
            if (self.height == -1) {
                block.previousBlockHash = "";
            }
            // update pBH otherwise
            else {
                block.previousBlockHash = self.chain[self.chain.length - 1].hash;
            }

            // update block hash
            block.hash = SHA256(JSON.stringify(self.data)).toString();

            // update UTC timestamp
            block.time = new Date().getTime().toString().slice(0,-3);

            // update blockchain height
            self.height += 1;

            // update block height
            block.height = self.height;

            self.chain.push(block);
            resolve(block);

          }
          catch(err) {
            reject(err + "occured!");
          }

        });
    }

    /**
     * The requestMessageOwnershipVerification(address) method
     * will allow you  to request a message that you will use to
     * sign it with your Bitcoin Wallet (Electrum or Bitcoin Core)
     * This is the first step before submit your Block.
     * The method return a Promise that will resolve with the message to be signed
     * @param {*} address
     */
    requestMessageOwnershipVerification(address) {
        return new Promise((resolve) => {
          resolve(address + ":" + new Date().getTime().toString().slice(0,-3) + ":starRegistry");
        });
      }

    /**
     * The submitStar(address, message, signature, star) method
     * will allow users to register a new Block with the star object
     * into the chain. This method will resolve with the Block added or
     * reject with an error.
     * Algorithm steps:
     * 1. Get the time from the message sent as a parameter example: `parseInt(message.split(':')[1])`
     * 2. Get the current time: `let currentTime = parseInt(new Date().getTime().toString().slice(0, -3));`
     * 3. Check if the time elapsed is less than 5 minutes
     * 4. Veify the message with wallet address and signature: `bitcoinMessage.verify(message, address, signature)`
     * 5. Create the block and add it to the chain
     * 6. Resolve with the block added.
     * @param {*} address
     * @param {*} message
     * @param {*} signature
     * @param {*} star
     */
    submitStar(address, message, signature, star) {
        let self = this;
        return new Promise(async (resolve, reject) => {

          let messageTime = parseInt(message.split(':')[1]);
          let currentTime = parseInt(new Date().getTime().toString().slice(0, -3));

          let FIVE_MIN=5*60*1000;

          if (messageTime - currentTime > FIVE_MIN) {
            reject('Delayed by more than 5 minutes');
          }

          if (!bitcoinMessage.verify(message, address, signature)) {
            reject('Unable to verify!');
          }

          let newBlock = new BlockClass.Block({data: star});
          await self._addBlock(newBlock);

          resolve(newBlock);

        });
    }

    /**
     * This method will return a Promise that will resolve with the Block
     *  with the hash passed as a parameter.
     * Search on the chain array for the block that has the hash.
     * @param {*} hash
     */
     getBlockByHash(hash) {
      let self = this;
      return new Promise((resolve, reject) => {
        for (let blocks of self.chain) {
          if (hash == blocks.hash) {
            resolve(blocks);
          }
        }
        // no charge
        reject("Block not found");
      });
    }

    /**
     * This method will return a Promise that will resolve with the Block object
     * with the height equal to the parameter `height`
     * @param {*} height
     */
    getBlockByHeight(height) {
        let self = this;
        return new Promise((resolve, reject) => {
            let block = self.chain.filter(p => p.height === height)[0];
            if(block){
                resolve(block);
            } else {
                resolve(null);
            }
        });
    }

    /**
     * This method will return a Promise that will resolve with an array of Stars objects existing in the chain
     * and are belongs to the owner with the wallet address passed as parameter.
     * Remember the star should be returned decoded.
     * @param {*} address
     */
    getStarsByWalletAddress (address) {
        let self = this;
        let stars = [];
        return new Promise((resolve, reject) => {

          // change for loop str of others
          try {

            var i;
            // skip genesis block
            for (i = 1; i < self.chain.length; i++) {
                let block = self.chain[i];
                let blockData = block.getBData();
                stars.push(blockData);
            }

            resolve(stars);

          }
          catch(err) {
            reject(err + "occured");
          }

        });
    }

    /**
     * This method will return a Promise that will resolve with the list of errors when validating the chain.
     * Steps to validate:
     * 1. You should validate each block using `validateBlock`
     * 2. Each Block should check the with the previousBlockHash
     */
    validateChain() {
      let self = this;
      let errorLog = [];
      return new Promise(async (resolve, reject) => {

        for (let blocks of self.chain) {

          let curHeight = 0;

          blocks.validate().then(function(boolean) {
             if (boolean == false) {
               errorLog.push(blocks.height + "did not validate");
             }
           });

          if (curHeight != 0 && blocks.previousBlockHash != blocks[curHeight - 1].hash) {

            errorLog.push(blocks.height + "did not hash with prev block");
          }

          curHeight += 1;
        }

        resolve(errorLog);
      });
    }

}

module.exports.Blockchain = Blockchain;
